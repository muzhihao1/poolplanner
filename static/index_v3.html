<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>台球桌自动布局系统 - 增强版</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f5f5f5;
        }
        
        #root {
            min-height: 100vh;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background-color: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            color: #333;
            font-size: 28px;
            margin-bottom: 5px;
        }
        
        .header p {
            color: #666;
            font-size: 16px;
        }
        
        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .view-button {
            padding: 8px 16px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .view-button.active {
            border-color: #4CAF50;
            background-color: #4CAF50;
            color: white;
        }
        
        .zoom-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .zoom-button {
            width: 30px;
            height: 30px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
        }
        
        .zoom-level {
            margin: 0 10px;
            font-size: 14px;
            color: #666;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .main-content.fullscreen {
            grid-template-columns: 250px 1fr;
        }
        
        .control-panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }
        
        .control-panel.compact {
            padding: 15px;
        }
        
        .canvas-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            overflow: auto;
        }
        
        .canvas-wrapper {
            display: inline-block;
            position: relative;
        }
        
        canvas {
            border: 1px solid #ddd;
            cursor: crosshair;
            display: block;
        }
        
        .field-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .field-info div {
            margin-bottom: 5px;
        }
        
        .field-info .large-field {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
            width: calc(100% - 10px);
        }
        
        .button:hover {
            background-color: #45a049;
        }
        
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .button.secondary {
            background-color: #ff9800;
        }
        
        .button.secondary:hover {
            background-color: #e68900;
        }
        
        .button.danger {
            background-color: #f44336;
        }
        
        .button.danger:hover {
            background-color: #da190b;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }
        
        .input-group input,
        .input-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .stats {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .stats h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .stats div {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-button {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            background-color: #fff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .mode-button.active {
            border-color: #4CAF50;
            background-color: #4CAF50;
            color: white;
        }
        
        .obstacles-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .obstacle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background-color: #f8f9fa;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .obstacle-item button {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .preset-fields {
            margin-bottom: 15px;
        }
        
        .preset-button {
            padding: 8px 15px;
            margin: 5px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .preset-button:hover {
            background: #f0f0f0;
        }
        
        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 4px;
            overflow: hidden;
            display: none;
        }
        
        .minimap.show {
            display: block;
        }
        
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
        
        .display-options {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        .display-options h4 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .checkbox-group {
            margin-bottom: 8px;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .checkbox-group input[type="checkbox"] {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // API基础URL
        const API_BASE_URL = window.location.origin;
        
        // 绘制模式
        const DrawMode = {
            BOUNDARY: 'boundary',
            OBSTACLE: 'obstacle',
            VIEW: 'view'
        };
        
        // 视图模式
        const ViewMode = {
            NORMAL: 'normal',
            FIT: 'fit',
            LARGE: 'large'
        };
        
        // 预设场地
        const PRESET_FIELDS = [
            { name: '小型 (10×10m)', width: 10000, height: 10000 },
            { name: '中型 (20×15m)', width: 20000, height: 15000 },
            { name: '大型 (30×20m)', width: 30000, height: 20000 },
            { name: '超大型 (50×30m)', width: 50000, height: 30000 },
            { name: '巨型 (40×25m)', width: 40000, height: 25000 }
        ];
        
        function App() {
            // 状态管理
            const [drawMode, setDrawMode] = useState(DrawMode.VIEW);
            const [viewMode, setViewMode] = useState(ViewMode.NORMAL);
            const [boundaryPoints, setBoundaryPoints] = useState([]);
            const [obstacles, setObstacles] = useState([]);
            const [tables, setTables] = useState([]);
            const [isDrawing, setIsDrawing] = useState(false);
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [stats, setStats] = useState(null);
            const [error, setError] = useState(null);
            const [success, setSuccess] = useState(null);
            const [fieldArea, setFieldArea] = useState(0);
            const [distances, setDistances] = useState([]);
            
            // 显示选项
            const [showDistances, setShowDistances] = useState(true);
            const [showTableNumbers, setShowTableNumbers] = useState(true);
            const [showGrid, setShowGrid] = useState(true);
            const [showMinimap, setShowMinimap] = useState(true);
            
            // 配置参数
            const [config, setConfig] = useState({
                wall_distance: 1500,
                table_distance: 1400,
                table_width: 2850,
                table_height: 1550,
                grid_size: 100,
                optimize_count: true
            });
            
            // Canvas引用
            const canvasRef = useRef(null);
            const minimapRef = useRef(null);
            const [scale, setScale] = useState(0.05); // 50像素 = 1米
            const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [lastPanPoint, setLastPanPoint] = useState({ x: 0, y: 0 });
            
            // 计算场地面积
            const calculateArea = (points) => {
                if (points.length < 3) return 0;
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i][0] * points[j][1];
                    area -= points[j][0] * points[i][1];
                }
                return Math.abs(area) / 2 / 1000000; // 转换为平方米
            };
            
            // 计算台球桌之间的距离
            const calculateTableDistances = () => {
                const allDistances = [];
                
                // 台球桌之间的距离
                for (let i = 0; i < tables.length; i++) {
                    for (let j = i + 1; j < tables.length; j++) {
                        const table1 = tables[i];
                        const table2 = tables[j];
                        
                        // 获取实际边界
                        const bounds1 = {
                            x: table1.x,
                            y: table1.y,
                            width: table1.rotation === 90 ? table1.height : table1.width,
                            height: table1.rotation === 90 ? table1.width : table1.height,
                            right: table1.x + (table1.rotation === 90 ? table1.height : table1.width),
                            bottom: table1.y + (table1.rotation === 90 ? table1.width : table1.height)
                        };
                        
                        const bounds2 = {
                            x: table2.x,
                            y: table2.y,
                            width: table2.rotation === 90 ? table2.height : table2.width,
                            height: table2.rotation === 90 ? table2.width : table2.height,
                            right: table2.x + (table2.rotation === 90 ? table2.height : table2.width),
                            bottom: table2.y + (table2.rotation === 90 ? table2.width : table2.height)
                        };
                        
                        // 计算最短距离和连接点
                        const distances = [];
                        
                        // 水平距离（左右关系）
                        if (bounds1.right < bounds2.x) {
                            // table1在table2左边
                            const yOverlap = !(bounds1.bottom < bounds2.y || bounds1.y > bounds2.bottom);
                            if (yOverlap) {
                                const y1 = Math.max(bounds1.y, bounds2.y);
                                const y2 = Math.min(bounds1.bottom, bounds2.bottom);
                                const midY = (y1 + y2) / 2;
                                distances.push({
                                    distance: bounds2.x - bounds1.right,
                                    point1: [bounds1.right, midY],
                                    point2: [bounds2.x, midY],
                                    type: 'horizontal'
                                });
                            }
                        } else if (bounds2.right < bounds1.x) {
                            // table2在table1左边
                            const yOverlap = !(bounds1.bottom < bounds2.y || bounds1.y > bounds2.bottom);
                            if (yOverlap) {
                                const y1 = Math.max(bounds1.y, bounds2.y);
                                const y2 = Math.min(bounds1.bottom, bounds2.bottom);
                                const midY = (y1 + y2) / 2;
                                distances.push({
                                    distance: bounds1.x - bounds2.right,
                                    point1: [bounds1.x, midY],
                                    point2: [bounds2.right, midY],
                                    type: 'horizontal'
                                });
                            }
                        }
                        
                        // 垂直距离（上下关系）
                        if (bounds1.bottom < bounds2.y) {
                            // table1在table2上面
                            const xOverlap = !(bounds1.right < bounds2.x || bounds1.x > bounds2.right);
                            if (xOverlap) {
                                const x1 = Math.max(bounds1.x, bounds2.x);
                                const x2 = Math.min(bounds1.right, bounds2.right);
                                const midX = (x1 + x2) / 2;
                                distances.push({
                                    distance: bounds2.y - bounds1.bottom,
                                    point1: [midX, bounds1.bottom],
                                    point2: [midX, bounds2.y],
                                    type: 'vertical'
                                });
                            }
                        } else if (bounds2.bottom < bounds1.y) {
                            // table2在table1上面
                            const xOverlap = !(bounds1.right < bounds2.x || bounds1.x > bounds2.right);
                            if (xOverlap) {
                                const x1 = Math.max(bounds1.x, bounds2.x);
                                const x2 = Math.min(bounds1.right, bounds2.right);
                                const midX = (x1 + x2) / 2;
                                distances.push({
                                    distance: bounds1.y - bounds2.bottom,
                                    point1: [midX, bounds1.y],
                                    point2: [midX, bounds2.bottom],
                                    type: 'vertical'
                                });
                            }
                        }
                        
                        // 选择最短的垂直距离
                        if (distances.length > 0) {
                            const minDist = distances.reduce((min, d) => d.distance < min.distance ? d : min);
                            if (minDist.distance > 200) { // 只显示大于200mm的距离
                                allDistances.push({
                                    ...minDist,
                                    table1: i,
                                    table2: j
                                });
                            }
                        }
                    }
                }
                
                // 台球桌到墙壁的距离
                if (boundaryPoints.length >= 3) {
                    tables.forEach((table, tableIndex) => {
                        const bounds = {
                            x: table.x,
                            y: table.y,
                            width: table.rotation === 90 ? table.height : table.width,
                            height: table.rotation === 90 ? table.width : table.height,
                            right: table.x + (table.rotation === 90 ? table.height : table.width),
                            bottom: table.y + (table.rotation === 90 ? table.width : table.height)
                        };
                        
                        // 找到最近的墙壁边
                        const wallDistances = [];
                        
                        for (let i = 0; i < boundaryPoints.length; i++) {
                            const j = (i + 1) % boundaryPoints.length;
                            const p1 = boundaryPoints[i];
                            const p2 = boundaryPoints[j];
                            
                            // 判断是否是水平或垂直的墙
                            const isHorizontalWall = Math.abs(p1[1] - p2[1]) < 10;
                            const isVerticalWall = Math.abs(p1[0] - p2[0]) < 10;
                            
                            if (isHorizontalWall) {
                                // 水平墙
                                const wallY = p1[1];
                                const wallX1 = Math.min(p1[0], p2[0]);
                                const wallX2 = Math.max(p1[0], p2[0]);
                                
                                // 检查台球桌是否在墙的X范围内
                                if (!(bounds.right < wallX1 || bounds.x > wallX2)) {
                                    const midX = Math.max(bounds.x, wallX1) + Math.min(bounds.right - bounds.x, wallX2 - Math.max(bounds.x, wallX1)) / 2;
                                    if (wallY < bounds.y) {
                                        // 墙在上方
                                        wallDistances.push({
                                            distance: bounds.y - wallY,
                                            point1: [midX, bounds.y],
                                            point2: [midX, wallY],
                                            type: 'wall-vertical'
                                        });
                                    } else if (wallY > bounds.bottom) {
                                        // 墙在下方
                                        wallDistances.push({
                                            distance: wallY - bounds.bottom,
                                            point1: [midX, bounds.bottom],
                                            point2: [midX, wallY],
                                            type: 'wall-vertical'
                                        });
                                    }
                                }
                            } else if (isVerticalWall) {
                                // 垂直墙
                                const wallX = p1[0];
                                const wallY1 = Math.min(p1[1], p2[1]);
                                const wallY2 = Math.max(p1[1], p2[1]);
                                
                                // 检查台球桌是否在墙的Y范围内
                                if (!(bounds.bottom < wallY1 || bounds.y > wallY2)) {
                                    const midY = Math.max(bounds.y, wallY1) + Math.min(bounds.bottom - bounds.y, wallY2 - Math.max(bounds.y, wallY1)) / 2;
                                    if (wallX < bounds.x) {
                                        // 墙在左边
                                        wallDistances.push({
                                            distance: bounds.x - wallX,
                                            point1: [bounds.x, midY],
                                            point2: [wallX, midY],
                                            type: 'wall-horizontal'
                                        });
                                    } else if (wallX > bounds.right) {
                                        // 墙在右边
                                        wallDistances.push({
                                            distance: wallX - bounds.right,
                                            point1: [bounds.right, midY],
                                            point2: [wallX, midY],
                                            type: 'wall-horizontal'
                                        });
                                    }
                                }
                            }
                        }
                        
                        // 添加最近的墙壁距离
                        if (wallDistances.length > 0) {
                            const minWallDist = wallDistances.reduce((min, d) => d.distance < min.distance ? d : min);
                            if (minWallDist.distance > 200) {
                                allDistances.push({
                                    ...minWallDist,
                                    table1: tableIndex,
                                    table2: -1 // -1表示是墙
                                });
                            }
                        }
                    });
                }
                
                setDistances(allDistances);
            };
            
            // 更新场地面积和计算距离
            useEffect(() => {
                if (boundaryPoints.length >= 3) {
                    setFieldArea(calculateArea(boundaryPoints));
                }
            }, [boundaryPoints]);
            
            useEffect(() => {
                if (tables.length > 0) {
                    calculateTableDistances();
                }
            }, [tables]);
            
            // 自动调整视图
            const autoFitView = () => {
                if (boundaryPoints.length < 3) return;
                
                const canvas = canvasRef.current;
                const minX = Math.min(...boundaryPoints.map(p => p[0]));
                const maxX = Math.max(...boundaryPoints.map(p => p[0]));
                const minY = Math.min(...boundaryPoints.map(p => p[1]));
                const maxY = Math.max(...boundaryPoints.map(p => p[1]));
                
                const fieldWidth = maxX - minX;
                const fieldHeight = maxY - minY;
                
                const scaleX = (canvas.width - 100) / fieldWidth;
                const scaleY = (canvas.height - 100) / fieldHeight;
                const newScale = Math.min(scaleX, scaleY, 0.1); // 最大缩放0.1
                
                setScale(newScale);
                setPanOffset({
                    x: (canvas.width - fieldWidth * newScale) / 2 - minX * newScale,
                    y: (canvas.height - fieldHeight * newScale) / 2 - minY * newScale
                });
            };
            
            // 设置预设场地
            const setPresetField = (preset) => {
                const boundary = [
                    [0, 0],
                    [preset.width, 0],
                    [preset.width, preset.height],
                    [0, preset.height]
                ];
                setBoundaryPoints(boundary);
                setObstacles([]);
                setTables([]);
                setDistances([]);
                setTimeout(autoFitView, 100);
            };
            
            // 缩放控制
            const handleZoom = (delta) => {
                const newScale = Math.max(0.01, Math.min(0.2, scale + delta));
                setScale(newScale);
            };
            
            // 处理鼠标滚轮缩放
            const handleWheel = (e) => {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.005 : 0.005;
                    handleZoom(delta);
                }
            };
            
            // 处理鼠标拖动
            const handleMouseDown = (e) => {
                if (drawMode === DrawMode.VIEW || e.button === 1) { // 中键或视图模式
                    setIsPanning(true);
                    setLastPanPoint({ x: e.clientX, y: e.clientY });
                } else if (drawMode === DrawMode.BOUNDARY) {
                    const canvas = canvasRef.current;
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - panOffset.x) / scale;
                    const y = (e.clientY - rect.top - panOffset.y) / scale;
                    setBoundaryPoints([...boundaryPoints, [x, y]]);
                } else if (drawMode === DrawMode.OBSTACLE) {
                    const canvas = canvasRef.current;
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - panOffset.x) / scale;
                    const y = (e.clientY - rect.top - panOffset.y) / scale;
                    setObstacles([...obstacles, {
                        type: 'rectangle',
                        center: [x, y],
                        size: [400, 400]
                    }]);
                }
            };
            
            const handleMouseMove = (e) => {
                if (isPanning) {
                    const dx = e.clientX - lastPanPoint.x;
                    const dy = e.clientY - lastPanPoint.y;
                    setPanOffset({
                        x: panOffset.x + dx,
                        y: panOffset.y + dy
                    });
                    setLastPanPoint({ x: e.clientX, y: e.clientY });
                }
            };
            
            const handleMouseUp = () => {
                setIsPanning(false);
            };
            
            // 绘制函数
            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 保存变换状态
                ctx.save();
                ctx.translate(panOffset.x, panOffset.y);
                ctx.scale(scale, scale);
                
                // 绘制网格（根据缩放级别调整）
                if (showGrid) {
                    const gridSize = scale > 0.05 ? 1000 : 5000; // 1m或5m网格
                    ctx.strokeStyle = '#f0f0f0';
                    ctx.lineWidth = 1 / scale;
                    
                    const startX = Math.floor(-panOffset.x / scale / gridSize) * gridSize;
                    const endX = Math.ceil((canvas.width - panOffset.x) / scale / gridSize) * gridSize;
                    const startY = Math.floor(-panOffset.y / scale / gridSize) * gridSize;
                    const endY = Math.ceil((canvas.height - panOffset.y) / scale / gridSize) * gridSize;
                    
                    for (let x = startX; x <= endX; x += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, startY);
                        ctx.lineTo(x, endY);
                        ctx.stroke();
                    }
                    for (let y = startY; y <= endY; y += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(startX, y);
                        ctx.lineTo(endX, y);
                        ctx.stroke();
                    }
                }
                
                // 绘制边界
                if (boundaryPoints.length > 2) {
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3 / scale;
                    ctx.beginPath();
                    ctx.moveTo(boundaryPoints[0][0], boundaryPoints[0][1]);
                    for (let i = 1; i < boundaryPoints.length; i++) {
                        ctx.lineTo(boundaryPoints[i][0], boundaryPoints[i][1]);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (boundaryPoints.length > 0) {
                    // 绘制边界点
                    ctx.fillStyle = '#333';
                    boundaryPoints.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point[0], point[1], 5 / scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
                
                // 绘制障碍物
                ctx.fillStyle = '#666';
                obstacles.forEach((obstacle, index) => {
                    if (obstacle.type === 'rectangle') {
                        const [x, y] = obstacle.center;
                        const [width, height] = obstacle.size;
                        ctx.fillRect(x - width/2, y - height/2, width, height);
                    }
                });
                
                // 绘制台球桌
                tables.forEach((table, index) => {
                    ctx.save();
                    ctx.translate(table.x, table.y);
                    
                    if (table.rotation === 90) {
                        ctx.translate(table.height / 2, table.width / 2);
                        ctx.rotate(Math.PI / 2);
                        ctx.translate(-table.width / 2, -table.height / 2);
                    } else {
                        ctx.translate(table.width / 2, table.height / 2);
                        ctx.translate(-table.width / 2, -table.height / 2);
                    }
                    
                    // 台球桌主体
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(0, 0, table.width, table.height);
                    
                    // 台球桌边框
                    ctx.strokeStyle = '#2E7D32';
                    ctx.lineWidth = 4 / scale;
                    ctx.strokeRect(0, 0, table.width, table.height);
                    
                    // 台球桌编号
                    if (showTableNumbers) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `bold ${300 / scale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const centerX = table.width / 2;
                        const centerY = table.height / 2;
                        ctx.fillText(index + 1, centerX, centerY);
                    }
                    
                    ctx.restore();
                });
                
                // 绘制距离标注
                if (showDistances && distances.length > 0) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.fillStyle = '#ff6600';
                    ctx.lineWidth = 2 / scale;
                    ctx.font = `${200 / scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    distances.forEach(dist => {
                        const [x1, y1] = dist.point1;
                        const [x2, y2] = dist.point2;
                        
                        // 绘制距离线
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        
                        // 绘制箭头
                        const arrowSize = 100 / scale;
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(
                            x1 + arrowSize * Math.cos(angle + Math.PI / 6),
                            y1 + arrowSize * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(
                            x1 + arrowSize * Math.cos(angle - Math.PI / 6),
                            y1 + arrowSize * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 + arrowSize * Math.cos(angle + Math.PI - Math.PI / 6),
                            y2 + arrowSize * Math.sin(angle + Math.PI - Math.PI / 6)
                        );
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 + arrowSize * Math.cos(angle + Math.PI + Math.PI / 6),
                            y2 + arrowSize * Math.sin(angle + Math.PI + Math.PI / 6)
                        );
                        ctx.stroke();
                        
                        // 绘制距离文本
                        const midX = (x1 + x2) / 2;
                        const midY = (y1 + y2) / 2;
                        const distanceM = (dist.distance / 1000).toFixed(2);
                        
                        // 背景
                        ctx.save();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        const textWidth = ctx.measureText(distanceM + 'm').width;
                        ctx.fillRect(
                            midX - textWidth / 2 - 5 / scale,
                            midY - 120 / scale,
                            textWidth + 10 / scale,
                            240 / scale
                        );
                        ctx.restore();
                        
                        // 文本
                        ctx.fillStyle = dist.distance < config.table_distance ? '#ff0000' : '#ff6600';
                        ctx.fillText(distanceM + 'm', midX, midY);
                    });
                }
                
                ctx.restore();
                
                // 绘制小地图
                if (showMinimap) {
                    drawMinimap();
                }
            };
            
            // 绘制小地图
            const drawMinimap = () => {
                const minimap = minimapRef.current;
                if (!minimap || boundaryPoints.length < 3) return;
                
                const ctx = minimap.getContext('2d');
                ctx.clearRect(0, 0, minimap.width, minimap.height);
                
                // 计算边界
                const minX = Math.min(...boundaryPoints.map(p => p[0]));
                const maxX = Math.max(...boundaryPoints.map(p => p[0]));
                const minY = Math.min(...boundaryPoints.map(p => p[1]));
                const maxY = Math.max(...boundaryPoints.map(p => p[1]));
                
                const fieldWidth = maxX - minX;
                const fieldHeight = maxY - minY;
                
                const minimapScale = Math.min(
                    (minimap.width - 10) / fieldWidth,
                    (minimap.height - 10) / fieldHeight
                );
                
                ctx.save();
                ctx.translate(5, 5);
                ctx.scale(minimapScale, minimapScale);
                ctx.translate(-minX, -minY);
                
                // 绘制边界
                ctx.fillStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.moveTo(boundaryPoints[0][0], boundaryPoints[0][1]);
                for (let i = 1; i < boundaryPoints.length; i++) {
                    ctx.lineTo(boundaryPoints[i][0], boundaryPoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();
                
                // 绘制台球桌
                ctx.fillStyle = '#4CAF50';
                tables.forEach(table => {
                    if (table.rotation === 90) {
                        ctx.fillRect(table.x, table.y, table.height, table.width);
                    } else {
                        ctx.fillRect(table.x, table.y, table.width, table.height);
                    }
                });
                
                // 绘制视口
                const canvas = canvasRef.current;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2 / minimapScale;
                ctx.strokeRect(
                    -panOffset.x / scale,
                    -panOffset.y / scale,
                    canvas.width / scale,
                    canvas.height / scale
                );
                
                ctx.restore();
            };
            
            // 优化布局
            const handleOptimize = async () => {
                if (boundaryPoints.length < 3) {
                    setError('请先绘制场地边界');
                    return;
                }
                
                setIsOptimizing(true);
                setError(null);
                setSuccess(null);
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/layout/optimize`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            boundary: boundaryPoints,
                            obstacles: obstacles.map(obs => ({
                                x: obs.center[0] - obs.size[0]/2,
                                y: obs.center[1] - obs.size[1]/2,
                                width: obs.size[0],
                                height: obs.size[1]
                            })),
                            config: config
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('优化请求失败');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success && data.tables) {
                        setTables(data.tables);
                        setStats(data.stats);
                        setSuccess(`成功布置 ${data.count} 个台球桌`);
                        
                        // 大场地提示
                        if (fieldArea > 500) {
                            setSuccess(`成功布置 ${data.count} 个台球桌（大场地模式）`);
                        }
                    } else {
                        throw new Error(data.error || '优化失败');
                    }
                } catch (err) {
                    setError(err.message);
                } finally {
                    setIsOptimizing(false);
                }
            };
            
            // 清除边界
            const clearBoundary = () => {
                setBoundaryPoints([]);
                setTables([]);
                setStats(null);
                setFieldArea(0);
                setDistances([]);
            };
            
            // 清除障碍物
            const clearObstacles = () => {
                setObstacles([]);
                setTables([]);
                setStats(null);
                setDistances([]);
            };
            
            // 删除障碍物
            const removeObstacle = (index) => {
                const newObstacles = [...obstacles];
                newObstacles.splice(index, 1);
                setObstacles(newObstacles);
            };
            
            // 更新配置
            const updateConfig = (key, value) => {
                setConfig({
                    ...config,
                    [key]: value
                });
            };
            
            // 重绘
            useEffect(() => {
                draw();
            }, [boundaryPoints, obstacles, tables, scale, panOffset, showDistances, showTableNumbers, showGrid, showMinimap, distances]);
            
            // 设置canvas尺寸
            useEffect(() => {
                const updateCanvasSize = () => {
                    const canvas = canvasRef.current;
                    const container = canvas.parentElement;
                    if (viewMode === ViewMode.LARGE) {
                        canvas.width = Math.max(container.clientWidth - 40, 1200);
                        canvas.height = Math.max(window.innerHeight - 200, 600);
                    } else {
                        canvas.width = container.clientWidth - 40;
                        canvas.height = 600;
                    }
                    draw();
                };
                
                updateCanvasSize();
                window.addEventListener('resize', updateCanvasSize);
                return () => window.removeEventListener('resize', updateCanvasSize);
            }, [viewMode]);
            
            return (
                <div className="container">
                    <div className="header">
                        <div>
                            <h1>台球桌自动布局系统</h1>
                            <p>智能优化台球厅布局，精确距离标注</p>
                        </div>
                        <div className="view-controls">
                            <div className="view-buttons">
                                <button 
                                    className={`view-button ${viewMode === ViewMode.NORMAL ? 'active' : ''}`}
                                    onClick={() => setViewMode(ViewMode.NORMAL)}
                                >
                                    标准视图
                                </button>
                                <button 
                                    className={`view-button ${viewMode === ViewMode.FIT ? 'active' : ''}`}
                                    onClick={() => {
                                        setViewMode(ViewMode.FIT);
                                        autoFitView();
                                    }}
                                >
                                    适应视图
                                </button>
                                <button 
                                    className={`view-button ${viewMode === ViewMode.LARGE ? 'active' : ''}`}
                                    onClick={() => setViewMode(ViewMode.LARGE)}
                                >
                                    大场地视图
                                </button>
                            </div>
                            <div className="zoom-controls">
                                <button className="zoom-button" onClick={() => handleZoom(-0.01)}>-</button>
                                <span className="zoom-level">{Math.round(scale * 2000)}%</span>
                                <button className="zoom-button" onClick={() => handleZoom(0.01)}>+</button>
                                <button className="zoom-button" onClick={autoFitView}>⊡</button>
                            </div>
                        </div>
                    </div>
                    
                    <div className={`main-content ${viewMode === ViewMode.LARGE ? 'fullscreen' : ''}`}>
                        <div className={`control-panel ${viewMode === ViewMode.LARGE ? 'compact' : ''}`}>
                            <div className="mode-buttons">
                                <button
                                    className={`mode-button ${drawMode === DrawMode.VIEW ? 'active' : ''}`}
                                    onClick={() => setDrawMode(DrawMode.VIEW)}
                                >
                                    查看
                                </button>
                                <button
                                    className={`mode-button ${drawMode === DrawMode.BOUNDARY ? 'active' : ''}`}
                                    onClick={() => setDrawMode(DrawMode.BOUNDARY)}
                                >
                                    边界
                                </button>
                                <button
                                    className={`mode-button ${drawMode === DrawMode.OBSTACLE ? 'active' : ''}`}
                                    onClick={() => setDrawMode(DrawMode.OBSTACLE)}
                                >
                                    障碍
                                </button>
                            </div>
                            
                            {/* 预设场地 */}
                            <div className="preset-fields">
                                <label>快速选择场地：</label>
                                {PRESET_FIELDS.map((preset, index) => (
                                    <button
                                        key={index}
                                        className="preset-button"
                                        onClick={() => setPresetField(preset)}
                                    >
                                        {preset.name}
                                    </button>
                                ))}
                            </div>
                            
                            {/* 配置参数 */}
                            <div className="input-group">
                                <label>墙壁安全距离 (mm)</label>
                                <input
                                    type="number"
                                    value={config.wall_distance}
                                    onChange={(e) => updateConfig('wall_distance', parseInt(e.target.value))}
                                />
                            </div>
                            
                            <div className="input-group">
                                <label>台球桌间距 (mm)</label>
                                <input
                                    type="number"
                                    value={config.table_distance}
                                    onChange={(e) => updateConfig('table_distance', parseInt(e.target.value))}
                                />
                            </div>
                            
                            <div className="input-group">
                                <label>优化策略</label>
                                <select
                                    value={config.optimize_count ? 'count' : 'regular'}
                                    onChange={(e) => updateConfig('optimize_count', e.target.value === 'count')}
                                >
                                    <option value="regular">规则布局</option>
                                    <option value="count">最大化数量</option>
                                </select>
                            </div>
                            
                            {/* 显示选项 */}
                            <div className="display-options">
                                <h4>显示选项</h4>
                                <div className="checkbox-group">
                                    <label>
                                        <input
                                            type="checkbox"
                                            checked={showDistances}
                                            onChange={(e) => setShowDistances(e.target.checked)}
                                        />
                                        显示距离标注
                                    </label>
                                </div>
                                <div className="checkbox-group">
                                    <label>
                                        <input
                                            type="checkbox"
                                            checked={showTableNumbers}
                                            onChange={(e) => setShowTableNumbers(e.target.checked)}
                                        />
                                        显示台球桌编号
                                    </label>
                                </div>
                                <div className="checkbox-group">
                                    <label>
                                        <input
                                            type="checkbox"
                                            checked={showGrid}
                                            onChange={(e) => setShowGrid(e.target.checked)}
                                        />
                                        显示网格
                                    </label>
                                </div>
                                <div className="checkbox-group">
                                    <label>
                                        <input
                                            type="checkbox"
                                            checked={showMinimap}
                                            onChange={(e) => setShowMinimap(e.target.checked)}
                                        />
                                        显示小地图
                                    </label>
                                </div>
                            </div>
                            
                            {/* 操作按钮 */}
                            <button 
                                className="button"
                                onClick={handleOptimize}
                                disabled={isOptimizing || boundaryPoints.length < 3}
                            >
                                {isOptimizing ? '优化中...' : '优化布局'}
                            </button>
                            
                            <button 
                                className="button secondary"
                                onClick={clearBoundary}
                            >
                                清除边界
                            </button>
                            
                            <button 
                                className="button danger"
                                onClick={clearObstacles}
                            >
                                清除障碍物
                            </button>
                            
                            {/* 障碍物列表 */}
                            {obstacles.length > 0 && (
                                <div className="obstacles-list">
                                    <h3>障碍物列表</h3>
                                    {obstacles.map((obstacle, index) => (
                                        <div key={index} className="obstacle-item">
                                            <span>障碍物 {index + 1}</span>
                                            <button 
                                                className="button danger"
                                                onClick={() => removeObstacle(index)}
                                            >
                                                删除
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            )}
                            
                            {/* 统计信息 */}
                            {stats && (
                                <div className="stats">
                                    <h3>布局统计</h3>
                                    <div>
                                        <span>台球桌数量：</span>
                                        <span>{stats.table_count} 个</span>
                                    </div>
                                    <div>
                                        <span>场地面积：</span>
                                        <span>{stats.total_area} m²</span>
                                    </div>
                                    <div>
                                        <span>空间利用率：</span>
                                        <span>{stats.space_utilization}%</span>
                                    </div>
                                    <div>
                                        <span>平均间距：</span>
                                        <span>{stats.average_distance} mm</span>
                                    </div>
                                </div>
                            )}
                            
                            {/* 提示信息 */}
                            {error && (
                                <div style={{color: 'red', marginTop: '10px'}}>
                                    {error}
                                </div>
                            )}
                            {success && (
                                <div style={{color: 'green', marginTop: '10px'}}>
                                    {success}
                                </div>
                            )}
                        </div>
                        
                        <div className="canvas-container">
                            <div className="canvas-wrapper">
                                <canvas 
                                    ref={canvasRef}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onMouseLeave={handleMouseUp}
                                    onWheel={handleWheel}
                                />
                                {fieldArea > 0 && (
                                    <div className="field-info">
                                        <div>场地面积: {fieldArea.toFixed(1)} m²</div>
                                        {fieldArea > 500 && (
                                            <div className="large-field">大场地模式</div>
                                        )}
                                        {tables.length > 0 && (
                                            <div>台球桌: {tables.length} 个</div>
                                        )}
                                    </div>
                                )}
                            </div>
                            {fieldArea > 200 && viewMode === ViewMode.LARGE && showMinimap && (
                                <div className="minimap show">
                                    <canvas ref={minimapRef} width="200" height="150" />
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }
        
        // 渲染应用
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>